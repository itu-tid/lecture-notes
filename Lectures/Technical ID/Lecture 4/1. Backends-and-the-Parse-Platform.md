# Backends and the Parse Platform

Motivation - we have a todo list application that saves info in local storage. But this is not enough. We want to save the information on a server and access it from anywhere. 

## Backends

### What is a backend? 
- **Relative term** - defined in opposition to the *front-end*
	- **Front-end** -- code that runs in the user's browser and handles presentation and user interaction
	- **Back-end** -- handles data processing, storage, and security
- The server side in a ***client-server architecture***

![](images/client-server-architecture.png)


### What are the **responsibilities of the backend**?
- Authentication (proving that a user is who they say they are)
- Authorization (what can a user do)
- Session management for web applications
- Business logic and DB access
- Scheduled jobs (e.g., `cron`)
- API endpoints / request handling (since the backend receives and responds to requests)
- Data validation (ensuring incoming data is correct/safe)

### Setting up a traditional backend
- Machine setup (or create a VM with a cloud provider)
- Operating system installation & configuration
- Security & firewall configuration
- Database management system (DBMS)
- Web server (e.g. nginx, apache2)
- Application server / runtime environment 
- Logging, monitoring & analytics
- Backup system


### Low-Code Backends
- Pre-built solutions for common backend needs
- Backend-as-a-service
	- Firebase = proprietary, hosted by Google
	- Back-for-App.com = a deployment of Parse
- Self-hostable
	- **Parse Platform** = open source framework 


## Parse Platform

### History

Startup => Facebook => [Open Source](https://github.com/parse-community)

### Implementation

Implemented in JS - runs on Node

Offers
- Server
	- Authentication
	- Authorization
	- File storage
	- APIs (REST & GraphQL)
	- Interactive Dashboard for DB Management
	- Cloud functions
- Client
	- Javascript SDK in the `parse` wrapper library for the client
	- SDKs for other languages and UI frontends (Android, iOS, etc.)



## Setting up a Parse Server
### Using Parse from Back4App

Steps to start working with the Back4App Parse deployment 
1. Create an account on Back4App
2. Create a backend (app) for your react application in Back4App
4. In your own project, install the `parse` library from `npm`
5. Initialize the (global) Parse object in your application (see step 4 in the [back4app guide](https://www.back4app.com/docs/react/quickstart))
 
Now you can interact with the database from within React in the following ways.

### Using your own deployment

- you can also deploy your own server
- we'll see that if we have enough time


# Interacting with Parse from Javascript

The full documentation is in the [Parse.js Javascript Guide](https://docs.parseplatform.org/js/guide/#saving-objects)
- reference 

## Connecting to a server

- install the parse JS SDK (software development kit)
- configure your react application to connect to the server and corresponding app (there might be multiple apps on the server)

```js
Parse.initialize("YOUR_APP_ID", "YOUR_JAVASCRIPT_KEY");
//javascriptKey is required only if you have it on server.

Parse.serverURL = 'http://YOUR_PARSE_SERVER:1337/parse'
```
Note: code above should be in the top level component of our app.

## CRUD Operations

*To Read*: [CRUD operations with Parse](https://www.back4app.com/docs/react/data-objects/react-crud-tutorial) (approx. 30min)

CRUD stands for
- Create
- Retrieve
- Update
- Delete

### Creating and Saving a New Object to the Database

```javascript
import Parse from 'parse';

const Counter = Parse.Object.extend("Counter");
const counter = new Counter();

counter.set("name", "Push Ups");
counter.set("count", 10);

counter.save().then(
	(newObj) => {
		alert("saved a counter with id: " + newObj.id);
}, (error) => {
	alert(error.message);
})
```

Steps: 
1. Creating a class for the object
2. `save()` - sends the data to the server
3. save returns a *promise* so we  have to unpack it `save.then( (obj) => {...})` 
4. The `Counter` class is automatically been created in the database if it didn't exist - behavior that can be turned off

Advanced Parse functionalities: 
- [saving objects when offline](https://docs.parseplatform.org/js/guide/#saving-objects-offline) with `saveEventually`
- 
### Retrieving an Object

```js
const GameScore = Parse.Object.extend("GameScore");
const query = new Parse.Query(GameScore);
query.get("xWMyZ4YEGZ")
.then((gameScore) => {
	const score = gameScore.get("score");
	const playerName = gameScore.get("playerName");
	const cheatMode = gameScore.get("cheatMode");
	// or
	const { score, playerName, cheatMode } = gameScore.attributes;
	// note, id is a special kind of property - you don't get with get
	const objectId = gameScore.id;
}, (error) => {
  // The object was not retrieved successfully.
  // error is a Parse.Error with an error code and message.
});
```

### Updating an Object

```js

// Create the object.
const GameScore = Parse.Object.extend("GameScore");
const gameScore = new GameScore();

gameScore.set("score", 1337);
gameScore.set("playerName", "Sean Plott");
gameScore.set("cheatMode", false);
gameScore.set("skills", ["pwnage", "flying"]);

gameScore.save().then((gameScore) => {
  // Now let's update it with some new data. In this case, only cheatMode and score
  // will get sent to the cloud. playerName hasn't changed.
  gameScore.set("cheatMode", true);
  gameScore.set("score", 1338);
  return gameScore.save();
});

```

Advanced Parse features
- [Atomic counters](https://docs.parseplatform.org/js/guide/#counters)
- [Atomic arrays](https://docs.parseplatform.org/js/guide/#arrays)


## Querying for Objects 

Most basic way to query for objects is: 
```jsx
const GameScore = Parse.Object.extend("GameScore");
const query = new Parse.Query(GameScore);
query.equalTo("playerName", "Dan Stemkoski");
const results = await query.find();
alert("Successfully retrieved " + results.length + " scores.");
// Do something with the returned Parse.Object values
for (let i = 0; i < results.length; i++) {
  const object = results[i];
  alert(object.id + ' - ' + object.get('playerName'));
}
```
Steps: 
- Create a class reference
- Create a query object
- Add constraints on the query object
- call `.find()`

References: 
- [Query Constraints](https://docs.parseplatform.org/js/guide/#query-constraints)
- [Queries on Arrays](https://docs.parseplatform.org/js/guide/#queries-on-array-values)
- [Queries on Strings](https://docs.parseplatform.org/js/guide/#queries-on-string-values)
- 

## User Management with Parse

### Account Creation and Authentication

The Javascript Parse SDK helps you manage user accounts and track the logged in user. 

The following example is a simple page that either creates an account or logs in the user.

```jsx
import { useState } from 'react';
import Parse from 'parse';

function Auth() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSignUp = async (e) => {
    e.preventDefault();
    setError('');
    try {
      const user = new Parse.User();
      user.set('username', username);
      user.set('password', password);
      await user.signUp();
      alert('Sign up successful!');
    } catch (err) {
      setError(err.message);
    }
  };

  const handleLogin = async (e) => {
    e.preventDefault();
    setError('');
    try {
      await Parse.User.logIn(username, password);
      alert('Login successful!');
    } catch (err) {
      setError(err.message);
    }
  };

  return (
    <div>
      <h1>Auth</h1>
      {error && <p style={{ color: 'red' }}>{error}</p>}
      
      <form>
        <input
          type="text"
          placeholder="Username"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
        />
        <input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <button onClick={handleSignUp}>Sign Up</button>
        <button onClick={handleLogin}>Log In</button>
      </form>
    </div>
  );
}

export default Auth;
```

What happens: 
- `Parse.User.signUp()` creates a new user
- `Parse.User.logIn()` logs in existing user
- Both methods automatically manage the session 
- Log out: `await Parse.User.logOut()`


### Getting the current user

It would be silly if the user had to login every time they opened the app
Parse stores info about the logged in user in LocalStorage
```jsx
const currentUser = Parse.User.current();
if (currentUser) {
    // do stuff with the user
} else {
    // show the signup or login page
}
```

### Logging out the current user

```jsx
Parse.User.logOut().then(() => {
  const currentUser = Parse.User.current();  // this will now be null
});
```

### Associations

Example of storing a `Post` for a `User`. 
- Create an attribute on the `Post`
- Query the posts for that user

```js
const user = Parse.User.current();

// Make a new post
const Post = Parse.Object.extend("Post");
const post = new Post();
post.set("title", "My New Post");
post.set("body", "This is some great content.");
post.set("user", user);
await post.save();
// Find all posts by the current user
const query = new Parse.Query(Post);
query.equalTo("user", user);
const userPosts = await query.find();
// userPosts contains all of the posts by the current user.
});
```



More advanced features
- [Email Verification](https://docs.parseplatform.org/js/guide/#verifying-emails)
- [Security of User Objects](https://docs.parseplatform.org/js/guide/#security-for-other-objects) - only a user can modify it's own data
- [Resetting Passwords](https://docs.parseplatform.org/js/guide/#resetting-passwords)


# React patterns when communicating with a backend

## Loading notification pattern

```jsx
import { useState, useEffect } from 'react';
import Parse from 'parse';

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchTodos = async () => {
      setLoading(true);
      try {
        const Todo = Parse.Object.extend('Todo');
        const query = new Parse.Query(Todo);
        const results = await query.find();
        setTodos(results);
      } catch (error) {
        console.error('Error fetching todos:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchTodos();
  }, []);

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>Todos</h1>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>{todo.get('title')}</li>
        ))}
      </ul>
    </div>
  );
}

export default TodoList;
```




# Modeling Relationships in Parse


You must think ahead about the database model for your application. 

The main questions are 
1. What are the types of objects in my domain model?
2. What are the relationships between them?


## Relationships 

### One-to-many Relationships

Can be implemented with 
1. Pointers - the default one
2. Arrays - for special situations where the "many" are "few" :)

#### Creating a relationship with pointers
```jsx
var game = new Parse.Object("Game");
game.set("createdBy", Parse.User.current());
```

now we can query all the games of a user using:
```js
var query = new Parse.Query("Game");
query.equalTo("createdBy", Parse.User.current());
```
of get the user who created a game: 

```js
// say we have a Game object
var game = ...

// getting the user who created the Game
var user = game.get("createdBy");
```
#### Creating a relationship with arrays

```js
// let's say we have four weapons
var scimitar = ...
var plasmaRifle = ...
var grenade = ...
var bunnyRabbit = ...

// stick the objects in an array
var weapons = [scimitar, plasmaRifle, grenade, bunnyRabbit];

// store the weapons for the user
var user = Parse.User.current();
user.set("weaponsList", weapons);
```

To retrieve the Weapon objects: 
```js
var weapons = Parse.User.current().get("weaponsList")
```
### Many-to-Many Relationships

Can be implemented in two ways
1. Using the Parse Relation attribute type
2. Using join tables

#### Using Parse Relations

##### Defining a relation between authors and books

```js
// let’s say we have a few objects representing Author objects
var authorOne = ...
var authorTwo = ...
var authorThree = ...

// now we create a book object
var book = new Parse.Object("Book");

// now let’s associate the authors with the book
// remember, we created a "authors" relation on Book
var relation = book.relation("authors");
relation.add(authorOne);
relation.add(authorTwo);
relation.add(authorThree);

// now save the book object
book.save();
```
##### Getting the authors of a book

```js
// suppose we have a book object
var book = ...

// create a relation based on the authors key
var relation = book.relation("authors");

// generate a query based on that relation
var query = relation.query();

// now execute the query
```
##### Getting all the books to which an author has contributed

```js
// suppose we have a author object, for which we want to get all books
var author = ...

// first we will create a query on the Book object
var query = new Parse.Query("Book");

// now query the authors relation to see if the author object we have is contained therein
query.equalTo("authors", author);
```

Note
- the `equalTo` is not intuitive

#### Using Join Tables

Create a new kind of entity that maps one authors to one book. 
```javascript
var author = ...

// create an entry in the BookAuthor table
var bookAuthor = new Parse.Object("BookAuthor");
bookAuthor.set("book", book);
bookAuthor.set("author", author);
bookAuthor.save();
```

This is always more powerful from the point of view of modeling! 

##### Why are Join Tables more powerful than relationships? 

Because they allow you to model the relationship in a more rich manner later! E.g. if you need to know author order, or the type of contribution (editor, primary author, co-author, etc.)
```javascript
var author = ...

// create an entry in the BookAuthor table
var bookAuthor = new Parse.Object("BookAuthor");
bookAuthor.set("book", book);
bookAuthor.set("author", author);
bookAuthor.set("role", "primary author");
bookAuthor.set("order", 1);
bookAuthor.set("dateAdded", Date());
bookAuthor.save();
```


## Entity-Relationship Diagrams

Use whichever notation you prefer. Two that I like are: 
1. On the left hand side is the most popular way of showing attributes 
	- crow's feet show cardinality
	- attributes are listed in the box
2. On the right hand side is a compressed approach proposed by Søren Lauesen, ex-professor at ITU

![](images/alterantive-er-diagrams.png)

No matter which notation you use, the most important aspect is being able to communicate the way all the relevant data for your application domain is saved in the database. 
# Project Work
- Design a **domain model** for your application by **creating an ER diagram**. The diagram will be part of your final report. Discuss your diagram with the staff. Make sure to keep it up to date as your project progresses. As you work on your implementation you will realize that you need to constantly refine it. Keep it up to date.
- Create the tables corresponding to your ER diagram in Back4App
- Start connecting your React application to your own Parse backend


# References

The documentation on ParsePlatform.org
- [Getting Started Guide](https://docs.parseplatform.org/js/guide/#getting-started) - extensive reference for everything ParseJS
- [Relationships](https://docs.parseplatform.org/js/guide/#relations) - this is very good and must be read attentively -- it will really help with modeling


# Meta
## History
- Oct '25 - Improved structure - made the page more stand-alone - less external references
- Nov '24 - better organized the references
## To Do
- Nov'24 - make sure to spend more time discussing the Relationships