# Running Code Server-Side

## Introduction: Client vs Server Code

One of the nice things is that with Parse we did not have to implement a server.

All the code runs on the client side until now. `Parse.Query`, `Parse.Object` - they're APIs that run in the context of our Application.

However, for some kinds of code, we will need to run it on a server.

### When to Use Server-Side Code

You need to write code that *runs on the server* for:
- **Statistics and aggregations** that might involve the data of all the users (e.g., average rating of all the movies in the database; one does not want send all that data to the client; it is good to do the calculations on the server)
- **Calling 3rd party APIs** (especially those that require a secret API key that can't be hardcoded in the Javascript)
	- e.g. your application offers Google Translate functionality
- **Validation and side effects** making a check before a user writes something to the database or updating some other metadata after a write is done

**Discussion:** Think of examples of computational tasks from your own project that would benefit from server-side execution. 

## Cloud Functions in Parse

In Parse, cloud functions are:
- Defined on the server and run in the context of the server
- Called from the JS client by name with parameters

### Example: Calculating Category Statistics Across All Users

#### Calling from the Client

Example of how to call a `getCategoryStats` cloud function from the client:

```js
const params = {category: "Important & Urgent"};
const stats = await Parse.Cloud.run("getCategoryStats", params);
console.log(`Average time: ${stats.avgTime}, Total tasks: ${stats.count}`);
console.log(`Completed in last 24h: ${stats.completedCount}`);
```

#### Implementation on the Server

Such a function assumes that on the server the implementation of the `getCategoryStats` is present. A possible implementation could be:

```js
Parse.Cloud.define("getCategoryStats", async (request) => {

	// Calculate the date 24 hours ago
	const now = new Date();
	const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);

	const query = new Parse.Query("TodoItem");
	query.equalTo("category", request.params.category);
	query.greaterThanOrEqualTo("createdAt", oneDayAgo);
	// Note: NO userId filter - we want stats across ALL users

	const results = await query.find();

	let totalTime = 0;
	let completedCount = 0;

	for (let i = 0; i < results.length; ++i) {
		totalTime += results[i].get("totalTime") || 0;
		if (results[i].get("done")) {
			completedCount++;
		}
	}

	return {
		count: results.length,
		avgTime: results.length > 0 ? totalTime / results.length : 0,
		totalTime: totalTime,
		completedCount: completedCount
	};
});
```

**Why run this on the server?**
- You don't want to send all users' todo data to the client (privacy + bandwidth)
- The calculation happens on the server where the data lives
- The client only receives the final statistics

**Optimization tip:** For expensive statistics like this, you could cache the results in a separate table and refresh them periodically (e.g., once per day) instead of recalculating on every request. This reduces server load and saves money.

**Key observations:**
- We can still use the `Parse.Query` API on the server
- The params sent from the client are stored in the `request.params`
- The currently logged-in user is available as `request.user` (not used in this example)
- The function is defined as `async` so it's returning a promise

### Deploying Cloud Functions

To declare cloud functions in Parse one has to go to the `Dashboard` > `Cloud Code` and add it to the `main.js` file under the `cloud` folder (see [example](https://www.back4app.com/docs/get-started/cloud-functions)). Once declared, you have to use the `Deploy` button at the bottom of the editor.

## Database Triggers

Parse allows you to automatically run functions when data is saved to the database. This is useful for validation, data transformation, and maintaining consistency.

### beforeSave: Running Code Before Writes

You can automatically run a function on the server before a user makes a write to the database using the `beforeSave` method of `Parse.Cloud`.

#### Example: Validating Todo Names

```js
Parse.Cloud.beforeSave("TodoItem", (request) => {

	const name = request.object.get("name");

	if (!name || name.trim().length === 0) {
		throw new Parse.Error(400, "Todo name cannot be empty");
	}

	if (name.length > 200) {
		// Truncate and add a ...
		request.object.set("name", name.substring(0, 197) + "...");
	}

	// Ensure totalTime is never negative
	const totalTime = request.object.get("totalTime");
	if (totalTime < 0) {
		request.object.set("totalTime", 0);
	}
});
```

#### Discussion Questions

- What does the above code do?
- How could a user abuse your system if you don't implement the above code?
- If you check for name length in JavaScript in the UI of your application... why would you still have to check right before saving a TodoItem also on the server?
- Why is it important to validate on the server even if you validate on the client?

### afterSave: Running Code After Writes

You can define a function that is automatically called *after* a user makes a write to the database using the `afterSave` method.

#### Example: Tracking Completed Tasks

```js
Parse.Cloud.afterSave("TodoItem", async (request) => {

	// Only run this logic if the task was just marked as done
	if (request.object.get("done") === true &&
	    request.original &&
	    request.original.get("done") === false) {

		// Create a log entry for analytics
		const CompletionLog = Parse.Object.extend("CompletionLog");
		const log = new CompletionLog();

		log.set("userId", request.object.get("userId"));
		log.set("category", request.object.get("category"));
		log.set("timeSpent", request.object.get("totalTime"));
		log.set("completedAt", new Date());

		try {
			await log.save();
			console.log("Completion logged successfully");
		} catch (error) {
			console.error("Error logging completion: " + error.message);
		}
	}
});
```

#### Discussion Questions

- What does the above code do?
- Why do we check `request.original`?
- How could this data be useful for analytics or reporting?
- What other actions might you want to trigger when a task is completed? 
