
# Efficient Communication With the Backend

The separation between front-end and back-end is new: one used to do web development, and they did everything.

Today we talk about being a *full stack* developer if you can do both the backend and the front-end.

It is more satisfying to be full stack. And it's not much harder. This is because front-end is by definition event-driven, concurrent programming. Back-end is usually modeling and querying the DB.

This is why, it's worth for you, as naturally front-enders to have at least basic knowledge of backend. In this chapter we'll look at a few issues that are relevant for Parse Platform backends, but often will generalize to any kind of backend.


## Being Aware of Costs

Back4App, the hosted service of Parse costs money. You are using a free tier, but you must realize that this is a cloud-based solution. For cloud-based solutions one has to pay.

Consequently, a free tier will have limitations. The limitations of the Back4App server ensure that you do not put too much pressure on the server.

### Parse Server Pricing and Limitations

The image below shows the prices and limitations of the Back4App various plans.

![](images/parse-server-plans.png)

In particular for the free tier, you have limited:
- number of requests
- data transfer
- data storage

### Impact on Design Decisions

Using a backend-as-a-service impacts how you design communication between your front-end and back-end. You have to be economical about resource usage because otherwise you:
- will spend more money than needed
- will have a slower application than necessary

### Case Study: MathsCamp

Looking at the networking tab in the screenshot below, we can see many requests being made:

![](images/maths-camp-lots-of-requests.png)

**Discussion:** Why might we need to improve this interaction? Is it to save money or is it to have a faster application?

## Querying the Backend Efficiently

If you have *limited requests* it makes sense to get as much data from the DB in one go, as opposed to run multiple queries.

This is not a problem only for backends-as-a-service - this is a general problem. If you are not smart about querying your backend you will end up with a slow application.

### The N+1 Select Problem

This is **one of the most popular ways** of using a DB sub-optimally. 

You send a query, get n objects back, and then for every one of those objects, you send another query to get more information.

**Why is this a problem?**
- It's slower than it needs to be
- In the particular case of cloud-hosted Parse, you're running out of requests faster

**How to solve it:** Get all the data at once by *joining* the corresponding tables. This is, retrieving data from two tables at once.

### Retrieving Data from Related Tables

By default, when you create a `Parse.Query` object you create it for a given table and you get back objects from that particular table. Pointers are retrieved only as the `objectID` of the actual object in the remote table. So normally, you'd have to send another query to bring also the object.

**Solution:** Use the `include` method of the `Parse.Query` object to specify that you want to include also the objects in the table pointed at by the pointers.

#### Example: Using `include` to fetch related objects

```javascript
// Fetch all todos with their associated user information
let query = new Parse.Query('Todo');
query.equalTo('completed', false);
query.include('createdBy');  // createdBy is a pointer to a User object
let queryResult = await query.find();

// Now you can access the full user object
console.log(queryResult[0].get('createdBy').get('username'));
```

In this example:
- Without `include`: `createdBy` would only be a pointer (just the objectID)
- With `include('createdBy')`: The full `User` object is populated and you can access properties like username, email, etc.
- This avoids making separate queries for each user (N+1 problem)

**Note:** The corresponding SQL statement is `join`.

### Field Selection: Retrieving Only Necessary Data

Just as sending too many queries is a problem, transferring from the server too much data that is not needed is also a problem. For example, if you need to display a simple list of todo titles, it would be a waste of *bandwidth* to transfer large description fields or attached files.

**Solution:** Use `exclude` and `select` methods to retrieve only the necessary fields from a table.

#### Example: Using `select` to get specific fields

```javascript
// Fetch only title and completed status for a todo list view
let query = new Parse.Query('Todo');
query.select('title', 'completed');
let queryResult = await query.find();

console.log(queryResult[0].get('title'));        // Available
console.log(queryResult[0].get('completed'));    // Available
console.log(queryResult[0].get('description') === undefined);  // true - not fetched
```

#### Example: Using `exclude` to omit large fields

```javascript
// Fetch all fields except the large description and attachments
let query = new Parse.Query('Todo');
query.exclude('description', 'attachments');
let queryResult = await query.find();

console.log(queryResult[0].get('title'));        // Available
console.log(queryResult[0].get('description') === undefined);  // true - excluded
```

**When to use each:**
- Use `select` when you need only a few specific fields (most common)
- Use `exclude` when you need most fields except a few large ones

**Note:** The corresponding SQL statement is `select title, completed from todos` instead of saying `select * from todos`.

## Real-Time Data Updates

For most situations, we don't have to update our UIs when the data in the DB changes, because most of the time, a user is editing their own data and nobody else is changing it in the background.

**When do we need real-time updates?** One notable exception are situations when a screen is showing information that's created by other users that needs to appear in real time (e.g. messages in a chat application, or comments in a social media platform).

### Polling: The Low-Tech Approach

How polling works:
- Set an [interval](https://developer.mozilla.org/en-US/docs/Web/API/Window/setInterval) (note that an interval is different than a [timeout](https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout))
- When the interval expires, request the data again from the server
- Redisplay if needed
	- make sure to specify the key for every of the items when rendering
	- update the list with the new data from the server (if the data has changed)

#### Important: Cleanup When Using Intervals in React

Make sure to use the special syntax of `useEffect` to **cleanup** the timer when the component is not visible anymore.

**Wrong way:**

```js
useEffect(() => {

  const interval = setInterval(() => {
	   // check for new messages
  }, 1000);

}, []);
```

**Right way:**

```js
useEffect(() => {
  // called with [] means on component load

  const interval = setInterval(() => {
	   // check for new messages
  }, 1000);

  // on component unload
  return () => {
    clearInterval(interval);
  };
}, []);
```

### Event-Driven Approaches: The Advanced Way

How event-driven updates work:
- Allow the server to send you events when something in your query has changed
- Update only when something has actually changed

#### Parse LiveQuery

Parse provides LiveQuery to enable real-time updates in your application. Instead of repeatedly asking the server "has anything changed?", the server notifies you automatically when data matching your query changes.

#### Example: Real-time todo updates

```javascript
// Step 1: Create a query for todos you want to monitor
let query = new Parse.Query('Todo');
query.equalTo('assignedTo', Parse.User.current());

// Step 2: Subscribe to the query
let subscription = await query.subscribe();

// Step 3: Handle different events

// When a new todo is created that matches the query
subscription.on('create', (todo) => {
  console.log('New todo created:', todo.get('title'));
  // Update your UI to show the new todo
});

// When an existing todo is updated
subscription.on('update', (todo) => {
  console.log('Todo updated:', todo.get('title'));
  // Update the specific todo in your UI
});

// When a todo is deleted
subscription.on('delete', (todo) => {
  console.log('Todo deleted:', todo.id);
  // Remove the todo from your UI
});

// When a todo enters the query results (e.g., assigned to you)
subscription.on('enter', (todo) => {
  console.log('Todo now matches query:', todo.get('title'));
  // Add the todo to your UI
});

// When a todo leaves the query results (e.g., reassigned to someone else)
subscription.on('leave', (todo) => {
  console.log('Todo no longer matches query:', todo.get('title'));
  // Remove the todo from your UI
});
```

#### Important: Cleanup in React

When using LiveQuery in React, make sure to unsubscribe when the component unmounts:

```javascript
useEffect(() => {
  let subscription;

  const setupLiveQuery = async () => {
    const query = new Parse.Query('Todo');
    query.equalTo('assignedTo', Parse.User.current());
    subscription = await query.subscribe();

    subscription.on('create', (todo) => {
      // Handle new todo
    });

    subscription.on('update', (todo) => {
      // Handle update
    });
  };

  setupLiveQuery();

  // Cleanup: unsubscribe when component unmounts
  return () => {
    if (subscription) {
      subscription.unsubscribe();
    }
  };
}, []);
```

**Benefits of LiveQuery over Polling:**
- Real-time updates without constant querying
- Reduced server load (fewer requests)
- Lower latency (instant updates)
- More efficient bandwidth usage

#### How It Works: WebSockets (Optional Deep Dive)

**Traditional HTTP requests** work like sending letters:
- Client asks a question → waits for response → connection closes
- To get updates, must keep asking "anything new?" over and over
- Each request has overhead (connection setup, headers, etc.)

**WebSocket connections** work like a phone call:
- Client establishes a connection that stays open
- Server can send messages anytime without being asked
- Two-way communication channel remains active
- Much more efficient for real-time updates

LiveQuery uses WebSocket connections under the hood. This is why it can push updates to your client instantly without polling. Parse implements this through the LiveQuery [protocol](https://github.com/parse-community/parse-server/wiki/Parse-LiveQuery-Protocol-Specification), but you don't need to understand the low-level protocol details to use it effectively.  


